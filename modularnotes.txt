Wed 10 Jan 15:46:41 GMT 2024

Idea here is to be modular and focus on readable code. Files are:

simple_opttree.c
code for tree building

workspace.c
provides working space (so as to avoid finding
new space during tree building)

tree.c
code for manipulating nodes/trees

sorted_set.c
code for policytree-style sorted sets

all other files are from other branches

Wed 13 Mar 14:37:07 GMT 2024

have now added reading.c/h and type_all.h

with commit:
cdf2f7030cfc210ae50190bbfc8dbadd5348ee62

get:
(base) uw20605@IT079795:~/repos/tailoring$ time ./a.out untracked/IFLS.txt 2 2
policy_tree object
Tree depth:   2
Actions:  1: "scores.DML" 2: "scores.DR"
Variable splits:
split_variable: "agecat.f2"  split_value: 0
  split_variable: "poorcard_imp"  split_value: 0
    * action: 2
    * action: 1
  * action: 1
Reward: 39.529

real	0m14.995s
user	0m14.986s
sys	0m0.008s

whereas should get a tree of reward of 69 with past_ind_mis at root.
However, depth=1 tree
base) uw20605@IT079795:~/repos/tailoring$ time ./a.out untracked/IFLS.txt 2 1
policy_tree object
Tree depth:   1
Actions:  1: "scores.DML" 2: "scores.DR"
Variable splits:
split_variable: "poorcard_imp"  split_value: 0
  * action: 2
  * action: 1
Reward: 32.0346

real	0m0.169s
user	0m0.153s
sys	0m0.016s
(base) uw20605@IT079795:~/repos/tailoring$ untracked/pt.R untracked/IFLS.txt 2 1
Warning in policy_tree(x, gammas, depth, TRUE) :
  The number of covariates exceeds 50. Consider reducing the dimensionality before running policy_tree, by for example using only the Xj's with the highest variable importance (`grf::variable_importance` - the runtime of exact tree search scales with ncol(X)^depth, see the documentation for details).
policy_tree object 
Tree depth:  1 
Actions:  1: scores.DML 2: scores.DR 
Variable splits: 
(1) split_variable: poorcard_imp  split_value: 0 
  (2) * action: 2 
  (3) * action: 1 

seems correct.

Found bug, not initialising left_perfect and right_perfect - now
getting the right tree!

Wed 13 Mar 17:07:18 GMT 2024

version about to be committed has been tested (and passed) with valgrind

Tue 19 Mar 15:19:30 GMT 2024

currently have two versions: sorted_sets and simple_sets. on binary
data the latter is far faster, on float data initial experiments show
sorted_sets faster. here's results on binary data:

(base) uw20605@IT079795:~/repos/tailoring$ time ./simple_set untracked/IFLS.txt 2 3
policy_tree object
Tree depth:   3
Actions:  1: "scores.DML" 2: "scores.DR"
Variable splits:
split_variable: "past_ind_mis"  split_value: 0
  split_variable: "agecat.f3"  split_value: 0
    split_variable: "province.f18"  split_value: 0
      * action: 2
      * action: 1
    split_variable: "province.f32"  split_value: 0
      * action: 2
      * action: 1
  split_variable: "region.f3-Jawa"  split_value: 0
    split_variable: "poorcard_imp"  split_value: 0
      * action: 2
      * action: 1
    split_variable: "past_mis"  split_value: 0
      * action: 1
      * action: 2
Reward: 117.766

real	0m17.022s
user	0m17.000s
sys	0m0.016s
(base) uw20605@IT079795:~/repos/tailoring$ time ./sorted_set untracked/IFLS.txt 2 3
policy_tree object
Tree depth:   3
Actions:  1: "scores.DML" 2: "scores.DR"
Variable splits:
split_variable: "past_ind_mis"  split_value: 0
  split_variable: "agecat.f3"  split_value: 0
    split_variable: "province.f18"  split_value: 0
      * action: 2
      * action: 1
    split_variable: "province.f32"  split_value: 0
      * action: 2
      * action: 1
  split_variable: "region.f3-Jawa"  split_value: 0
    split_variable: "poorcard_imp"  split_value: 0
      * action: 2
      * action: 1
    split_variable: "past_mis"  split_value: 0
      * action: 1
      * action: 2
Reward: 117.766

real	8m8.125s
user	8m8.091s
sys	0m0.012s

Wed 20 Mar 14:52:13 GMT 2024

For R package, looking at policytree.
There is a file tree_search.h which has a prototype for a function
tree_search.
The file Rcppbindings.cpp defines a function tree_search_rcpp which
calls tree_search.
The R file policy_tree.R defines a function policy_tree which calls
tree_search_rcpp

tree_search.h is a "normal" C++ header file
Rcppbindings.cpp is a C++ file that references Rcpp types. This is the
equivalent of rcpp_hello_world.cpp in the skeleton.
So need to write our own C/C++ file to translate NODE* type into an R list.

Wed 20 Mar 19:53:37 GMT 2024

policytree approach
put root into queue
pop queue (now empty) and record stuff
push root->left_child
push root->right_child
pop root->left_child and record stuff
push root->left_child->left_child
push root->left_child->right_child
pop root->right_child

so process breadth-first, left to right.
